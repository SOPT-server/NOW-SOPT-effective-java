![](https://velog.velcdn.com/images/bo-ram-bo-ram/post/61bc7333-4ca1-48ef-8976-77faa0737e2f/image.png)


### 배경

정적 메서드와 정적 필드는 OOP에서 미움 받는 형식이지만 아래와 같은 상황에선 쓰임새가 존재한다.

1. 기본 타입 값이나 배열 관련 메서드들을 모아놓을 때
2. 특정 인터페이스를 구현하는 객체를 생성해주는 정적 메서드를 모아놓고 싶을 때
3. final 클래스와 관련한 메서드를 모아놓을 때
   <br/>

하지만 이런 형식은 다음과 같은 이슈가 발생한다.


>   💡 **이슈** <br/>
    정적 멤버만 담은 위와같은 클래스는 인스턴스로 만들어 쓰려고 설계한 것이 아니지만 컴파일러가 자동으로 기본 생성자를 만들어준다. 또 사용자는 이 생성자가 자동 생성된 것인지 구분이 불가하다.



이때 **추상 클래스**로 만들면 해결이 가능할까?
**아니다** 하위 클래스를 만들어서 인스턴스화를 하면 우회가 가능하다.
<br/>
그렇기 때문에 컴파일러가 기본 생성자를 만들지 못하도록 명시된 생성자가 없을 경우를 없애자.

이를 위해 **private 생성자를 추가하자**

```java
public class Utilityclass {
	// 기본 생성자가 만들어지는 것을 막는다（인스턴스화 방지용
	private UtilityClass() {
		throw new AssertionError();
		}
		... // 나머지 코드는 생략
}
```

클래스가 인스턴스화는 막아 주지만, 생성자가 존재하는데 호출이 불가능하니까 **주석**을 달아주자.

또한 이렇게 작성한다면 **상속을 불가능**하게 하는 효과도 있다. 모든 생성자는 상위 클래스의 생성자를 호출하게 되는데 이를 private로 선언했으니 상위 클래스의 생성자에 접근하는 길이 막힌다.