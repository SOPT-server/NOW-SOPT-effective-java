### 상속을 고려한 설계와 문서화


- 메서드를 재정의하면 어떤 일이 일어나는지 정확히 정리하여 문서화

  = 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서화

    1. 호출되는 메서드가 재정의 가능성 적시
    2. 호출 순서, 호출 결과가 이어지는 처리의 영향성
    - 예시

      > public boolean remove（Object o）
      주어진 원소가 이 컬렉션 안에 있다면 그 인스턴스를 하나 제거한다（선택적 동작）.
      더 정확하게 말하면, 이 컬렉션 안에 ‘Object.equals（o, e）가 참인 원소’ e가 하나 이상 있다면 그 중 하나를 제거한다. 주어진 원소가 컬렉션 안에 있었다면（즉, 호출 결과 이 컬렉션이 변경됐다면） true를 반환한다.
      Implementation Requirements： 이 메서드는 컬렉션을 순회하며 주어진 원소를 찾도록 구현되었다. 주어진 원소를 찾으면 반복자의 remove 메서드를 사용해 컬렉션에서 제거한다. 이 컬렉션이 주어진 객체를 갖고 있으나, 이 컬렉션의 iterator 메서드가 반환한 반복자가 remove 메서드를 구현하지 않았다면 UnsupportedOperationException을 던지니 주의하자.

- 클래스의 내부 동작 과정 중간에 끼어들 수 있는 hook을 선별하여 protected 메서드 형태로 공개
    - 예시

      > **`removeRange`** 메서드 : **`AbstractList`** 클래스에 정의되어 있으며, 리스트의 특정 범위의 요소를 제거하는 기능을 제공
      리스트 구현체의 내부 구조를 활용하여 부분 리스트의 **`clear`** 메서드 성능을 크게 개선할 수 있도록 함. 만약 이 메서드가 제공되지 않았다면, 하위 클래스에서 부분 리스트의 **`clear`** 메서드를 호출할 때 성능이 크게 저하되거나, 부분 리스트의 제거 메커니즘을 처음부터 새로 구현해야 할 것


<br>

### 상속을 허용하는 클래스가 지켜야 할 추가적 제약사항

1. 상속용 클래스의 생성자는 재정의 가능 메서드를 호출하면 안된다.
2. 상속용 클래스에서 cloneable이나 serializable을 구현할지 정의한다면 clone와 readObject 모두 재정의 가능 메서드를 호출해서는 안된다.
3. 상속용으로 설계하지 않은 클래스는 상속을 금지한다.
    - final로 선언한다.
    - 모든 생성자를 private나 package-private로 선언하고 public 정적 팩터리를 만들어준다.

    <br>
   
> **핵심정리**
상속용 클래스를 설계하기란 결코 만만치 않다. 클래스 내부에서 스스로를 어떻게 사용하는지 모두 문서로 남겨야하며, 일단 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 한다. 그렇지 않으면 그 내부 구현 방식을 믿고 활용하던 하위 클래스를 오작동하게 만들 수 있다 .다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있다. 그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않다면 상속을 금지하는 편이 나을 것이다. 상속을 금지하려면 클래스를 final로 선언하고나 생성자 모두를 외부에서 접근할 수 없도록 만들면 된다.
>