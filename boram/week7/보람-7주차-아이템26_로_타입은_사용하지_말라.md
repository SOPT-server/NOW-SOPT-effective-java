## 제네릭
제네릭(generic)은 자바 5부터 사용할 수 있으며, 제네릭을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에 알려줘 형변환 오류를 방지하고, 더 안전하고 명확한 프로그램을 만들 수 있다. 제네릭 타입을 사용하면 컴파일러가 형변환 코드를 자동으로 추가해준다.

## 주요 개념
1. 제네릭 클래스와 인터페이스
    타입 매개변수를 사용하는 클래스와 인터페이스를 말한다.
    예: List<E>는 원소의 타입을 나타내는 타입 매개변수 E를 받는다.

2. 매개변수화 타입:

    제네릭 타입에 실제 타입 매개변수를 지정한 것을 말한다.
    예: List<String>은 원소의 타입이 String인 리스트를 의미한다.

   3. raw type:
   제네릭 타입에서 타입 매개변수를 전혀 사용하지 않은 것.
   예: List는 List<E>의 로 타입이다.
   로 타입을 사용하면 타입 안전성과 표현력을 잃게 된다.
   
## 제네릭의 사용 예시
   1. 로 타입 사용 예 (사용하지 말 것):
```java
    private final Collection stamps = ...;
        stamps.add(new Coin(...)); // "unchecked call" 경고 발생
        for (Iterator i = stamps.iterator(); i.hasNext();) {
Stamp stamp = (Stamp) i.next(); // ClassCastException 발생 가능
    stamp.cancel();
}

```

    2. 매개변수화된 컬렉션 타입 사용 예:
```java
    private final Collection<Stamp> stamps = ...;
```
    
    3. 비한정적 와일드카드 타입 사용 예:
```java
    static int numElementsInCommon(Set<?> s1, Set<?> s2) {
    int result = 0;
    for (Object o1 : s1) {
        if (s2.contains(o1)) result++;
    }
    return result;
}

```

## 로 타입 사용을 피해야 하는 이유
로 타입을 사용하면 타입 안전성을 잃게 되어 런타임 오류가 발생할 수 있다.
대신, 비한정적 와일드카드 타입을 사용하면 더 안전하게 코드를 작성할 수 있다.

## 예외 사항
1. class 리터럴:
- 제네릭 타입의 class 리터럴은 사용할 수 없다.
- 예: List.class, String[].class, int.class는 허용되지만 List<String>.class, List<?>.class는 허용되지 않는다.

2. instanceof 연산자:
- 런타임에 제네릭 타입 정보가 지워지므로, instanceof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다.
예:
```java
  if (o instanceof Set) { // 로 타입
  Set<?> s = (Set<?>) o; // 와일드카드 타입
  }
```

## 핵심 정리
raw type을 사용하면 런타입외 예외가 일어날 수 있으니 사용하면 안됟나. raw type은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다.