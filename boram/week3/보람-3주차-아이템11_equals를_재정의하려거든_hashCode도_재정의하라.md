### 배경

> **equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다.** 그렇지 않으면 hashCode 일반 규약을 어기게 되어 HashMap이나 HashSet 같은 컬렉션의 원소로 사용할 때 문제가 생길 수도 있다.
>

**hashCode**

Java의 모든 객체는 `hashCode` 메서드를 가진다. Java에서는 HashMap, HashSet 등 hash를 활용한 Collection들을 자주 볼 수 있는데 모두 `hashCode`를 기반으로 하고 있다. ****`Object#hashCode`구현은 다음과 같다.

```
public native int hashCode();
```

즉, native call을 통해 해당 객체의 메모리 해쉬 주소를 가져온다. 이 값은 `System#identityHashCode`와 동일한 값을 가진다.

### Object 명세 규약

1. equals 비교에 사용되는 정보가 똑같으면 hashCode는 몇 번을 호출해도 일관되게 같은 값을 반환해야 한다.
2. equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.
3. equals(Object)가 두 객체를 다르다고 판단했다고, 다른 hashCode를 반환할 필요는 없지만, 다른 값을 반환해야 해시테이블의 성능이 좋아진다.

### 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다.

`equals`가 물리적으로 다른 두 객체를 논리적으로 같다고 할 때, `hashCode`는 서로 다른 값을 반환한다.

```java
Map<PhoneNumber, String> map = new HashMap<>();
map.put(new PhoneNumber(010,1234,5678), new Person("리치"));
```

이 코드에 `map.get(new PhoneNumber(010,1234,5678))`를 실행하면 `"리치"`가 아닌 `null`을 반환한다.`PhoneNumber` 클래스는 `hashCode`를 재정의하지 않았기 때문에, 논리적 동치인 두 객체가 서로 다른 해시코드를 반환하여 `get` 메서드는 엉뚱한 해시 버킷에 가서 객체를 찾으려 한 것이다.**`HashMap`은 해시코드가 서로 다른 엔트리끼리는 동치성 비교를 시도조차 않도록 최적화 되어있다.**

### 좋은 해시 함수라면 서로 다른 인스턴스에 다른 해시코드를 반환한다.

### 좋은 `hashCode`를 작성하는 요령

1. int 변수인 `result`를 선언한 후 값을 c로 초기화한다.
    - 이 때, c는 해당 객체의 첫번째 핵심 필드를 단계 2.1 방식으로 계산한 해시코드이다.
    - 여기서 핵심 필드는 `equals` 비교에 사용되는 필드를 말한다.
2. 해당 객체의 나머지 핵심 필드인 f 각각에 대해 다음 작업을 수행한다.
    1. 해당 필드의 해시코드 c 를 계산한다.
        - 기본 타입 필드라면, `Type.hashCode(f)`를 수행한다. 여기서 *Type*은 해당 기본타입의 박싱 클래스다.
        - 참조 타입 필드면서, 이 클래스의 `equals` 메소드가 이 필드의 `equals`를 재귀적으로 호출하여 비교한다면, 이 필드의 `hashCode`를 재귀적으로 호출한다.
        - 필드가 배열이라면, 핵심 원소 각각을 별도 필드처럼 다룬다.모든 원소가 핵심 원소라면 `Arrays.hashCode`를 사용한다.
    2. 단계 2.1에서 계산한 해시코드 c로 `result`를 갱신한다.
        - `result` = 31 * `result` + c;
3. `result`를 반환한다.

### 주의할 점

- `equals`비교에 사용되는 필드에 대해서만 해시코드를 계산한다.
- 성능을 높인답시고 해시코드를 계산할 때 핵심 필드를 생략해서는 안 된다.
- 만약 hash로 바꾸려는 필드가 기본 타입이 아니면 해당 필드의 hashCode를 불러 구현한다.계산이 복잡한 경우는 표준형을 만들어 구현한다.
- 참조 타입 필드가 null일 경우 0을 사용.
- 31을 곱하는 이유는 비슷한 필드가 여러개일 때 해시효과를 크게 높여주기 위해서다.비슷한 값들이 여러개 있을때 그냥 더하면 같은 값이 나올 확률이 높다.그래서 31을 곱해 큰수로 만들어 해시효과를 증가시킨다.

### 핵심 정리

> equals를 재정의할 때는 hashCode도 반드시 재정의해야 한다. 그렇지 않으면 프로그램이 제대로 동작하지 않을 것이다. 재정의한 hashCode는 Object의 API 문서에 기술된 일반 규약을 따라야 하며, 서로 다른 인스턴스라면 되도록 해시코드도 서로 다르게 구현해야 한다. 이렇게 구현하기가 어렵지는 않지만 조금 따분한 일이긴 하다.
하지만 걱정마시라. 아이템10에서 이야기한 AutoValue 프레임워크를 사용하면 멋진 equals와 hashCode를 자동으로 만들어준다.
>