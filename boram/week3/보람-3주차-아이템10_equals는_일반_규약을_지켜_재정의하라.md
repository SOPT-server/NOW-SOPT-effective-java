equals는 재정의하기 쉬워보이지만 함정이 많다. 그러므로 되도록 재정의하지 말자.

### 재정의하지 않는 것이 좋은 상황

- 각 인스턴스가 본질적으로 고유하다. ex. Thread
- 인스턴스의 논리적 동치성을 검사할 일이 없다.
- 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
- 클래스가 private 이거나 package-private이고 equals 메서드를 호출할 일이 없다.
- 클래스가 private 이거나 package-private 이고 equals 메서드를 호출할 일이 없다.
    - 만약 equals가 실수로라도 호출되는걸 막고 싶다면 아래처럼 하자.

    ```java
    @Override
    public boolean equals(Object o) {
        throw new AssertionError();  // 호출 금지
    }
    ```


### 재정의 해야하는 상황

논리적 동치성을 확인해야 하는데 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때해줘야한다. - 주로 값 클래스들(Integer와 String)

하지만 enum과 같이 값이 같은 인스턴스가 둘 이상 만들어지지않음을 보장하는 클래스라면 재정의하지 않아도 된다.

### equals 재정의 규약

- **반사성 (reflexivity) :** 객체는 자기 자신과 같아야 한다.
- **대칭성 (symmetry) :** x.equals(y)가 참이면 그 반대(y.equals(x))도 참이어야 한다.
- **추이성(transitivity) :** 첫 번째 객체와 두 번째 객체가 같고, 두 번째 객체와 세 번째 객체가 같다면, 첫 번째 객체와 세 번째 객체도 같아야 한다.
- **일관성(consistency) :** 두 객체가 같다면 (수정되지 않는한) 앞으로 영원히 같아야 한다.
- **5. null-아님(non-null) :** 모든 객체가 null이 아니어야 한다.

  (x.equals(null)은 항상 false)


### 재정의 구현방법

1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다. 자기 자신이면 true를 반환한다.
2. instanceOf 연산자로 입력이 올바른 타입인지 확인한다.
3. 입력을 오바른 타입으로 형변환한다.
4. 입력 개체와 자기 자신의 대응되는 '핵심' 필드들이 모두 일치하는지 하나씩 검사한다.

### 핵심정리

> 꼭 필요한 경우가 아니면 equals를 재정의하지 말자. 많은 경우에 Object의 equals가 여러분이 원하는 비교를 정확히 수행해준다. 재정의해야 할 때는 그 클래스의 핵심 필드 모두를 빠짐없이 , 다섯 가지 규약을 확실히 지켜가며 비교해야 한다.
>