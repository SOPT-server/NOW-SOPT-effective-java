> 일반적으로 `다중 구현용 타입`은 `인터페이스가` 가장 적합하다.
복잡한 인터페이스라면 `인터페이스의 디폴트 메서드`를 제공하여 `골격을 구현`하자.
인터페이스의 구현 상 제약이 있다면 골격 구현은 추상 클래스로 제공하자.
>

자바가 제공하는 다중 구현 메커니즘 → 인터페이스와 추상 클래스

자바8부터 디폴트 메서드 제공 가능 → 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 제공 가능!

두 메커니즘의 가장 큰 차이는 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다는 점!

# 추상 클래스보다 인터페이스를 우선해야 하는 이유

## 1. 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다.

- 인터페이스일 때

  인터페이스가 요구하는 메서드가 아직 없다면 추가하고, 클래스 선언부에 implements만 추가하면 된다.

- 추상 클래스일 때

  기존 클래스 위에 새로운 추상 클래스를 끼워넣기 어렵다. 두 클래스가 같은 추상 클래스의 확장을 원한다면, 그 추상 클래스는 계층 구조 상 두 클래스의 공통 조상이어야 한다.
  또한 원치 않더라도 새로 추가된 추상 클래스의 모든 자손이 이를 상속하게 된다.


## 2. 인터페이스는 믹스인(mixin) 정의에 안성맞춤이다.

`믹스인(mix in)`: 해당 클래스의 주된 기능에 선택적 기능을 혼합(mixed in) 즉, 해당 클래스의 주된 타입 외에도 특정 선택적 행위를 제공

```java
// 로그 기능을 제공하는 Mixin 인터페이스
interface Loggable {
		void log(String message);
}

@AllArgsConstructor
class User implements Loggable {
		private String name;
		private String email;
		
		// '로그 기능'이라는 특정 선택적 행위를 제공
		@Override
		public void log(String message) {
				System.out.println("[User Log]: " + message);
		}
}
```

## 3. 인터페이스로는 계층 구조가 없는 타입 프레임워크를 만들 수 있다.

<aside>
💡 계층 구조로 잘 만드는게 쉬운 일이 아니다.

</aside>

타입을 계층적으로 정의하면 수많은 개념을 구조적으로 잘 표현할 수 있지만,

실세계에서는 계층을 엄격히 구분하기 어려운 개념도 있다.

- 계층화하기 어려운 예시

  `Singer`와 `SongWriter`의 관계에서 계층 구조가 있는 것은 아니다.

  하지만 `Singer`이면서 `SongWriter`가 있을 수 있다.

  두 인터페이스를 조합하여 새로운 인터페이스(타입)인 `SingerSongwriter`를 만들 수 있다!

    ```java
    interface Singer {
    		AudioClip sing(Song song);
    }
    
    interface Songwriter {
    		Song compose(int shartPositioin);
    }
    
    interface SingerSongwriter extends Singer, Songwriter {
    		AudioClip strum();
    		void actSensitive();
    }
    ```

  이 정도의 유연성이 항상 필요하다고 할 수는 없지만, 클래스로 만든다고 생각해보면 머리가 아프다.

  속성이 n개라면 지원해야 할 조합의 수는 2^n개 이고, 거대한 클래스 계층구조에는 공통 기능을 정의한 타입이 없기 때문에 자칫 매개변수 타입만 다른 메서드들을 수없이 많이 가진 거대한 클래스가 생길 수도 있다.


## 4. 래퍼 클래스 관용구와 함께 사용하면 인터페이스는 기능을 향상시키는 안전하고 강력한 수단이 된다.

타입을 추상 클래스로 정의하면 그 타입에 기능을 추가하는 방법은 상속밖에 없다.

상속하여 만든 클래스는 래퍼 클래스보다 활용도가 떨어지고 깨지기 더 쉽다.

인터페이스의 메서드 중 구현 방법이 명백한 것은 `디폴트 메서드`로 제공할 수 있다.

디폴트 메서드에도 제약은 존재한다.

### 디폴트 메서드의 제약

1. `equals`와 `hashCode` 같은 Object 메서드를 디폴트 메서드로 제공해서는 안 된다.
2. 인터페이스는 `인스턴스 필드`를 가질 수 없다.
3. `public이 아닌 정적 멤버`도 가질 수 없다. (private static 메서드는 예외)
4. 직접 만들지 않은 인터페이스에는 디폴트 메서드 자체를 추가할 수 없다.

# 인터페이스와 추상 골격 구현(abstract skeletal implementation) 클래스

인터페이스와 추상 골격 구현 클래스를 함께 제공하여 인터페이스와 추상 클래스의 장점을 모두 취할 수 있다.

이렇게 해두면 단순히 골격 구현을 확장하는 것만으로도 이 인터페이스를 구현하는 데 필요한 일이 대부분 완료된다. → 그리고 이게 `템플릿 메서드 패턴`이다.

- `인터페이스`: 타입 정의, 필요한 디폴트 메서드 몇 개
- `골격 구현 클래스`: 나머지 메서드들까지 구현

## 골격 구현 작성 순서

1. `인터페이스`를 잘 살펴 다른 메서드들의 구현에 사용되는 `기반 메서드`들을 `선정`

   → 이 기반 메서드들은 골격 구현에서는 추상 메서드가 됨

2. 기반 메서드들을 사용하여 직접 구현할 수 있는 메서드를 모두 인터페이스에서 `디폴트 메서드`로 제공

   → 물론 equals와 hashCode 같은 Object 메서드는 디폴트 메서드로 제공 불가


3. 인터페이스에서 기반 메서드나 디폴트 메서드로 만들지 못한 메서드가 남았다면,
   이 인터페이스를 구현하는 `골격 구현 클래스`를 만들어서 `남은 메서드`들을 `작성`
