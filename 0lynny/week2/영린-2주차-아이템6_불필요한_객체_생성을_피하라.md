## 아이템6. 불필요한 객체 생성을 피하라

똑같은 기능의 객체를 매번 생성하기 보다는 객체 하나를 재사용하는 것이 더 좋을 때가 많다.

아래와 같은 코드는 하지 말아야 하는 예시이다.

```java
String s = new String("ABC");
```

이 코드는 실행될 때마다 String 인스턴스를 새로 만들고 있다. 생성자로 만들어내는 String과 “ABC”가 일치하는데 계속해서 만들어준다면 String 인스턴스가 쓸데없이 많이 만들어질 것이다.

```java
String s = "ABC";
```

따라서 다음과 같이 작성하여 새로운 인스턴스를 매번 만들지 않고 하나의 String 인스턴스를 사용하는 것이 좋다. 이 방식은 똑같은 문자열을 사용하는 모든 코드가 같은 객체를 재사용하는 것이 보장된다. 

생성자 대신 정적팩터리 메서드를 제공하는 불변클래스에서는 정적 팩터리 메서드를 사용하여 불필요한 객체 생성을 방지할 수 있다. 

Boolean(String) 생성자 대신 Boolean.valueOf(String) 팩터리 메소드를 사용하는 것이 좋다. 또한 Boolean 처럼 불변객체가 아니더라도 사용하는 중에 변경이 되지 않는 다면 재사용도 가능하다.

생성 비용이 비싼 객체도 존재할 수 있는데, 이러한 경우 비싼 객체가 반복적으로 필요하다면 캐싱하여 재사용하는 것이 좋다. 

```java
static boolean isRomanNumeral(String s) {
    return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"
                    + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}
```

위 코드의 문제는 String.matches 메서드를 사용하는 데 있다. 해당 메서드는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만 정규표현식이 Pattern 인스턴스로 만들어져서 matches를 사용한 후에 인스턴스가 버려져서 성능 측면에서는 좋지 않다. 따라서 클래스 초기화 과정에서 직접 생성하여 캐싱해두고, 나중에 메서드가 호출될 때 마다 인스턴스를 재사용하면 성능을 개선할 수 있다. 

```java
static boolean isRomanNumeral(String s) {
    private static final Pattern Roman = Pattern.compile(
                    "^(?=.)M*(C[MD]|D?C{0,3})"
                    + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

    static boolean isRomanNumeral(String s) {
        return ROMAN.matcher(s).matches();
    }
}
```

이렇게 작성하면 pattern 인스턴스를 끄집어내고 이름도 지어주고 코드의 의미도 잘 드러나게 된다. 

이렇게 개선된 방식에서도 isRomanNumeral 메소드를 호출하지 않으면 쓸데없이 초기화된 꼴이다. 그래서 지연 초기화(lazy initialization)로 불필요한 초기화를 없앨 수 있지만 코드를 복잡하게 만들고 성능이 크게 개선되지 않기 때문에 권하지는 않는다.

객체가 불변이라면 재사용하면 안전하다는 것이 보장된다. 하지만 모든 객체의 인스턴스는 final이 아니다..

디자인 패턴 중에 어댑터 패턴(Adapter Pattern)을 생각해보자. 어댑처는 실제 작업은 뒷단 객체에 위임하고, 자신은 제 2의 인터세이스 역할을 해주는 객체이다. 따라서 어댑터는 뒤단 객체 외에는 관리할 상태가 없으므로, 뒷단 객체 하나당 어댑터 하나만 만들어주면 된다. 

또한 오토박싱의 예시도 불필요한 객체를 만들어내는 예시 중 하나이다.

오토박싱(auto boxing)이란 프로그래머가 기본타입과 박싱된 기본 타입을 섞어 쓸 때 자동으로 변환해주는 기술이다. 오토박싱은 기본 타입과 대응하는 박싱된 기본 타입의 구분을 흐리게 하지만 완전히 없애는 것은 아니다.

```java
private static long sum() {
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++)
        sum += i;

    return sum;
}
```

위의 코드는 long이 아닌 Long으로 선언하였기 때문에 불필요한 인스턴스가 만들어지게 된다. 따라서 효율을 위해 박싱된 기본타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자.

> ✅ **핵심 정리**
객체가 반복적으로 사용될 때는 인스턴스를 생성해서 캐싱하여 재사용하는 것이 좋다. 그리고 오토 박싱의 비효율이 발생하지 않도록 주의하자.
