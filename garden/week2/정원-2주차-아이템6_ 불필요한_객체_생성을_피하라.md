불변 객체 재사용

- 객체 하나를 매번 생성하기보다 재사용하는 편이 많다.
    
    → 재사용은 빠르고 세련되다.
    

```java
String s = new String("garden");
```

- 실행될 때마다 String 인스턴스를 새로 만든다.

```java
String s = "garden";
```

- 새로운 인스턴스를 매번 만드는 대신 하나의 String 인스턴스를 사용한다.

같은 가상 머신 안에서 이와 같은 문자열 리터럴을 사용하는 모든 코드가 같은 객체를 재사용함이 보장된다. 

생성자 대신 정적 팩터리 매서드를 제공하는 불변 클래스에서는 정적 팩터리 메서드를 사용해 불필요한 객체 생성을 피할 수 있다. 

→ ex) Boolean 생성자 대신 Boolean.valueOf(String) 팩터리 메서드를 사용하는 것이 좋다.

```java
static boolean isRomanNumeral(String s) {
	return s.matches("^(?=. )M*(C[MD]|D?C{0,3})"
					+ "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$")；
}
```

→ String.matches 메서드를 사용하는데 문제가 있다. 이 메서드 내부에서 만드는 정규표현식용 Pattern 인스턴스는 한번 쓰고 버려져서 곧바로 가비지 컬렉션 대상이 된다. Pattern은 입력받은 정규표현식에 해당하는 유한 상태 머신을 만들기 때문에 인스턴스 생성 비용이 높다.

```java
public class RomanNumerals {
	private static final Pattern ROMAN = Pattern.compile(
			"^(?=. )M*(C[MD]|D?C{0,3})"
					+ "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
	
	static boolean isRomanNumeral(String s) {
		return ROMAN.matcher(s).matches();
	}
}
```

→ 따라서 정규표현식을 표현하는 불변인 Pattern 인스턴스 클래스 초기화 과정에서 직접 캐싱해두고 나중에 이 인스턴스를 재사용하는 방향이 성능에 더 좋다.

지연 초기화

- 메서드가 처음 호출될 때 필드를 초기화해 생성하는 것을 미룰 수 있다.
- 지연 초기화 코드에 비해 성능이 크게 개선되지 않을 경우가 많다.

어댑터 객체

- 어댑터(뷰)란 실제 작업은 뒷단 객체에 위임하고, 자신은 제2의 인터페이스 역할을 해주는 객체다. 어댑터는 뒷단 객체만 관리하면 된다. 뒷단 객체 하나당 어댑터(뷰)가 하나씩 만들어진다.
- 예로 Map 인터페이스의 keySet 메서드가 Map 객체의 키를 모두 담은 Set 뷰(어댑터)를 반환한다. keySet을 호출할 때마다 새로운 Set 인스턴스가 만들어진다고 생각할 수 있지만 사실 매번 같은 Set 인스턴스가 반환된다.

오토 박싱

- 기본 타입과 래퍼 타입간에 변환을 자동으로 수행해주는 것이다.
- 박싱 과정에서 객체를 생성하기 때문에 성능면에서 문제가 될 수 있다.

```java
private static long sum() {
  Long sum = 0L;
  for (long i = 0; i <= Integer.MAX_VALUE; i++) {
    sum += i;
  }
  return sum;
}
```

→ Long 타입 인스턴스가 하나만 생성됐다고 생각하면 안 된다. sum += i 부분에서 Long 타입과 long 타입 즉, 기본 타입과 래퍼 타입간에 연산을 수행하기 위해 오토박싱이 일어난다(객체 생성). 불필요한 객체가 2^31 개나 생성된 것이다. 의도치 않은 오토박싱이 숨어들지 않도록 주의해야한다.

핵심 정리 

→ 단순히 객체 생성을 최대한 피하자는 것으로 오해하지 말자. 프로그램의 명확성, 간결성, 기능을 위해서 객체를 추가로 생성하는 것은 일반적으로 좋은 일이다.

→ 최근엔 JVM 성능이 좋아져서 작은 객체를 생성하고 가비지 콜렉트하는 것은 성능에 크게 영향을 주지 않는다. 아주 무거운 객체가 아니고서야 성능을 조금 개선시켜 보겠다고 직접 만든 객체 풀(pool)을 사용하는 것은 코드를 헷갈리게 만들고 오히려 성능을 떨어뜨릴 수 있다. 데이터베이스 커넥션과 같이 생성비용이 상당히 비싼 경우는 객체 재사용의 아주 좋은 예라고 볼 수 있다.

→ 이번 아이템은 새로운 객체를 만들어야 한다면 기존 객체를 재사용하지 마라 라는 방어적 복사와 대조적이다. 방어적 복사가 필요한 시점에 객체를 재사용하면 피해가 매우 크다. 버그와 보안 구멍으로 이어지는 경우가 많다. 그러나 불필요한 객체 생성은 코드형태와 성능에만 영향을 준다.